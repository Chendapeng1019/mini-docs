# springcloud feign

1. 为什么要用 Feign,能解决什么事
2. 自己撸一把 主要的几个注解的配置
3. 主要的配置
4. 主要的几个注解 EnableFeignClients FeignClient 工作原理 内部是如何玩转的 HTTP 的,能换 HTTP.
5. Ribbon 作用,实现,工作原理,负载和 Eureka 的关系 Hystrix 作用,实现,工作原理,常用隔离术
6. Feign 是如何集成 Ribbon,Hystrix,Feign Ribbon 模式,断路器模式,后备模式,舱壁模式

---

## 1. 基础知识

Feign 是一个声明式的 Web Service 客户端.它的出现使开发 Web Service 客户端变得很简单.使用 Feign 只需要创建一个接口加上对应的注解,比如：FeignClient 注解.Feign 有可插拔的注解,包括 Feign 注解和 JAX-RS 注解.Feign 也支持编码器和解码器,Spring Cloud Open Feign 对 Feign 进行增强支持 Spring MVC 注解,可以像 Spring Web 一样使用 HttpMessageConverters 等.

### 1.1 基础知识

### 1.2 helloworld

---

## 2. 常用配置与注解

### 2.1 常用配置

feign 常用配置如下:

### 2.2 常用注解

`FeignClient`注解被`@Target(ElementType.TYPE)`修饰,表示`FeignClient`常用注解如下:

|    注解名称     | 作用                                                                                                                  | 备注 |
| :-------------: | --------------------------------------------------------------------------------------------------------------------- | ---- |
|      name       | 指定 FeignClient 的名称,如果项目使用了 Ribbon, name 属性会作为微服务的名称,用于服务发现                               | -    |
|       url       | url 一般用于调试,可以手动指定@FeignClient 调用的地址.                                                                 | -    |
|    decode404    | 当发生 404 错误时,如果该字段为 true,会调用 decoder 进行解码,否则抛出 FeignException.                                  | -    |
|  configuration  | Feign 配置类,可以自定义 Feign 的 Encoder,Decoder,LogLevel,Contract.                                                   | -    |
|    fallback     | 定义容错的处理类,当调用远程接口失败或超时时,会调用对应接口的容错逻辑,fallback 指定的类必须实现@FeignClient 标记的接口 | -    |
| fallbackFactory | 工厂类,用于生成 fallback 类示例,通过这个属性我们可以实现每个接口通用的容错逻辑,减少重复的代码.                        | -    |
|      path       | 定义当前 FeignClient 的统一前缀.                                                                                      | -    |

### 2.3 服务降级模式

参考资料:[Hystrix 容错机制 link](https://blog.csdn.net/ZZY1078689276/article/details/88655457)

|        模式        | 作用                                                                                                                                                          | 备注 |
| :----------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| 服务熔断(Breaker)  | 当服务调用时,断路器将监视这个调用.如果用时太长,断路器会介入并中断调用,如果某一个远程资源的调用失败次数足够多,断路器将采取快速失败,阻止将来调用远程失败的资源. | -    |
| 服务回退(Fallback) | 当服务调用失败时,尝试通过其他方式执行操作,而不是生成一个异常.                                                                                                 | -    |
| 服务隔离(舱壁模式) | 可以把远程资源的调用分到线程池中,并降低一个缓慢的远程资源调用拖垮整个应用程序的风险.                                                                          | -    |

#### 2.3.1 服务熔断

服务熔断的概念来源于电路系统,在电路系统中存在一种熔断器(Circuit Breaker),当流经该熔断器的电路过大时就会自动切断电路.在微服务架构中,也存在类似现实世界中的服务熔断器,当某个异常条件被触发,直接熔断整个服务,而不是一直等待该服务超时.

这里需要注意的是,服务熔断器会把所有的调用结果都记录下来,如果发现异常的调用次数在单位时间内达到一定的阈值,那么服务熔断机制才会被触发,快速失败就会生效;反之则按照正常的流程执行远程调用.也就是说服务熔断器本身是有状态的,其状态主要分为`Closed`,`Open`,`Half-Open`三种情况.

- Closed:熔断器关闭状态,不对服务调用进行限制,但会对调用失败次数进行积累,达到一定阈值或比例时会启动熔断机制.

- Open:熔断器打开状态,此时对服务的调用将直接返回错误,不执行真正的网络调用.同时,熔断器设置了一个时钟选项,当时钟达到一定时间(这个时间一般设置成平均故障处理时间,也就是 MTTR)时会进入半熔断状态.

- Half-Open:半熔断状态,允许一定量的服务请求,如果调用都成功或达到一定比例则认为调用链路已恢复,关闭熔断器;否则认为调用链路仍然存在问题,又回到熔断器打开状态.

#### 2.3.2 服务回退

服务回退(Fallback)是处理因为服务依赖而导致的服务调用失败的一种有效容错机制(服务调用失败的情况包括异常、拒绝、超时、短路).当远程服务调用发生失败时,服务回退不是直接抛出该异常,而是产生另外的处理机制来应对该异常,相当于执行了另一条路径上的代码或返回一个默认的处理结果,而这条路径上的代码或这个默认处理结果一定满足业务逻辑的实现需求,它的作用只是告知服务的消费者当前调用中存在问题.

#### 2.3.3 服务隔离

在微服务的架构设计中存在一种舱壁隔离模式(Bulkhead Isolation Pattern),顾名思义就是像舱壁一样对资源或失败单元进行隔离,如果一个船舱破了进水,只损失一个船舱,其它船舱可以不受影响.舱壁隔离模式在微服务架构中的应用就是各种服务隔离思想.

所谓的隔离,本质上是对系统或资源进行分割,从而实现当系统发生故障时能够限定传播范围和影响范围,即发生故障后只有出问题的服务不可用,而保证其他服务仍然可用.

而服务的隔离又分为两种情况,分别是线程隔离与进程隔离

**线程隔离**:线程隔离主要通过线程池(Thread Pool)进行隔离,在实际使用时我们会把业务进行分类并交给不同的线程池进行处理.当某个线程池处理一种业务请求发生问题时,不会将故障扩散到其它线程池,也就是说不会影响到其它线程池中所运行的业务,从而保证其它服务可用.
线程隔离机制通过为每个依赖服务分配独立的线程池以实现资源隔离.当其中的一个服务所分配的线程被耗尽,也就是该服务的线程全部处于同步等待状态,也不会影响其他服务的调用,因为其他服务运行在独立的线程池中.

**进程隔离**: 进程隔离相较于线程隔离更加的容易理解,进程隔离就是将一个系统拆分为多个子系统以实现子系统间的物理隔离.由于各个子系统运行在独立的容器和 JVM 中,通过进程隔离使得某一个子系统出现问题不会影响到其它子系统.

---

## 3. Feign 工作原理

### 3.1 工作原理

### 3.2 替换 http

feign 默认使用 java 原生的`URLConnection`来请求,每一次都是打开一个线程来进行 http 请求.如果请求数量大的话,会累崩服务器的.所以在生产环境里面,需要更高效的 http 请求工具类代替原生的请求.

Q: So, just tell me ,what the fuck do you want ???

A: Calm down,be cool. httpclient is work for me.

在 pom.xml 添加 httpclient 依赖

```xml
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
</dependency>
<dependency>
    <groupId>com.netflix.feign</groupId>
    <artifactId>feign-httpclient</artifactId>
    <version>${feign-httpclient}</version>
</dependency>
```

yml 配置文件加入相关配置

```yml
feign:
  httpclient:
    enabled: true
```

---

## 4. 其他组件

### 4.1 ribbon

### 4.2 eureka

### 4.3 hystrix

---

## 5. 参考资料

a. [feign 工作原理博客](https://blog.csdn.net/u010066934/article/details/80967709)

b. [深入理解 Feign 之源码解析](https://zhuanlan.zhihu.com/p/28593019)
